<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AI-Powered Product Banner Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
  <style>
    body {
      background: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .upload-section {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .preview-section {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    #imagePreview {
      max-width: 300px;
      max-height: 300px;
      object-fit: contain;
    }
    canvas {
      border: 2px solid #ccc;
      margin-top: 20px;
    }
    .controls {
      margin: 20px 0;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
    }
    button:hover {
      background: #45a049;
    }
    .template-options {
      display: flex;
      gap: 10px;
      margin: 20px 0;
    }
    .template-option {
      border: 2px solid #ddd;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
    }
    .template-option.selected {
      border-color: #4CAF50;
    }
    .description-input {
      width: 100%;
      min-height: 100px;
      margin: 20px 0;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: Arial, sans-serif;
      resize: vertical;
    }
    .ai-suggestions {
      margin: 20px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 4px;
      border-left: 4px solid #4CAF50;
    }
    .theme-preview {
      display: flex;
      gap: 15px;
      margin: 15px 0;
    }
    .color-sample {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .input-group {
      margin: 15px 0;
    }
    .input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .input-group input, .input-group textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: Arial, sans-serif;
    }
    .input-group textarea {
      min-height: 100px;
      resize: vertical;
    }
    .loading {
      display: none;
      text-align: center;
      margin: 20px 0;
    }
    .loading:after {
      content: '...';
      animation: dots 1.5s steps(5, end) infinite;
    }
    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="upload-section">
    <h2>Create Your Banner</h2>
    
    <div class="input-group">
      <label for="productImage">Background Image (Optional)</label>
      <input type="file" id="productImage" accept="image/*">
    </div>

    <div class="input-group">
      <label for="productDescription">Description</label>
      <textarea id="productDescription" placeholder="Enter your description or prompt here... (e.g., 'Luxury leather handbags handcrafted in Italy' or 'Tech startup offering AI-powered solutions')"></textarea>
    </div>

    <div class="input-group">
      <label for="designPrompt">Design Style Preferences (Optional)</label>
      <textarea id="designPrompt" placeholder="Any specific design preferences? (e.g., 'Modern and minimalist' or 'Bold and vibrant')"></textarea>
    </div>

    <div class="preview-section">
      <div>
        <h3>Image Preview</h3>
        <img id="imagePreview" src="#" alt="Preview" style="display: none;">
      </div>
    </div>

    <div class="loading" id="loadingIndicator">Generating design</div>

    <div class="controls">
      <button id="generateBanner">Generate Banner</button>
      <button id="downloadBanner">Download Banner</button>
    </div>
  </div>

  <canvas id="adCanvas" width="800" height="200"></canvas>
</div>

<script>
  let model;
  let canvas;
  let imageFeatures = {};
  let currentStyleIndex = 0;
  let currentImage = null;
  
  // Design patterns based on product characteristics
  const designPatterns = {
    luxury: {
      patterns: ['diagonal', 'geometric', 'curved'],
      colors: ['gold', 'silver', 'deep'],
      elements: ['circles', 'diamonds', 'lines']
    },
    casual: {
      patterns: ['dots', 'waves', 'simple'],
      colors: ['bright', 'pastel', 'natural'],
      elements: ['squares', 'triangles', 'organic']
    },
    tech: {
      patterns: ['grid', 'circuit', 'minimal'],
      colors: ['neon', 'monochrome', 'cool'],
      elements: ['pixels', 'dots', 'lines']
    },
    nature: {
      patterns: ['organic', 'flowing', 'leafy'],
      colors: ['earth', 'forest', 'ocean'],
      elements: ['curves', 'leaves', 'waves']
    }
  };

  // Generate design theme based on product description
  function generateDesignTheme(description, colors) {
    const keywords = {
      luxury: ['luxury', 'premium', 'elegant', 'sophisticated', 'gold', 'silver'],
      tech: ['tech', 'digital', 'modern', 'smart', 'innovative'],
      casual: ['casual', 'comfortable', 'everyday', 'simple', 'fun'],
      nature: ['natural', 'organic', 'eco', 'green', 'sustainable']
    };

    // Determine product category based on description
    let category = 'casual'; // default
    let maxMatches = 0;
    
    Object.entries(keywords).forEach(([cat, words]) => {
      const matches = words.filter(word => 
        description.toLowerCase().includes(word.toLowerCase())
      ).length;
      if (matches > maxMatches) {
        maxMatches = matches;
        category = cat;
      }
    });

    // Get pattern set for category
    const patterns = designPatterns[category];

    // Generate specific theme
    return {
      category,
      mainPattern: patterns.patterns[Math.floor(Math.random() * patterns.patterns.length)],
      accentElements: patterns.elements[Math.floor(Math.random() * patterns.elements.length)],
      colorScheme: {
        primary: colors[0],
        secondary: colors[1],
        accent: colors[2]
      },
      style: {
        isGradient: Math.random() > 0.3,
        hasPattern: Math.random() > 0.2,
        patternOpacity: 0.1 + Math.random() * 0.3,
        elementCount: 3 + Math.floor(Math.random() * 5)
      }
    };
  }

  // Create pattern based on theme
  function createPattern(theme) {
    switch(theme.mainPattern) {
      case 'diagonal':
        return createDiagonalPattern(theme);
      case 'geometric':
        return createGeometricPattern(theme);
      case 'curved':
        return createCurvedPattern(theme);
      case 'grid':
        return createGridPattern(theme);
      default:
        return createSimplePattern(theme);
    }
  }

  function createDiagonalPattern(theme) {
    const pattern = [];
    const spacing = 15 + Math.random() * 10;
    const lineWidth = 1 + Math.random() * 2;
    
    // Create multiple layers of diagonal lines with varying opacities
    for(let layer = 0; layer < 4; layer++) {
      const angle = -45 + (layer * 15);
      const opacity = 0.05 + (layer * 0.05);
      
      for(let i = -canvas.height; i < canvas.width + canvas.height; i += spacing) {
        pattern.push(new fabric.Line([i, 0, i + canvas.height, canvas.height], {
          stroke: theme.colorScheme.accent,
          strokeWidth: lineWidth,
          opacity: opacity,
          angle: angle
        }));
      }
    }

    // Add floating geometric shapes
    const shapes = ['circle', 'triangle', 'rect'];
    for(let i = 0; i < 8; i++) {
      const shapeType = shapes[Math.floor(Math.random() * shapes.length)];
      const size = 10 + Math.random() * 20;
      const opacity = 0.1 + Math.random() * 0.1;
      
      let shape;
      switch(shapeType) {
        case 'circle':
          shape = new fabric.Circle({
            radius: size/2,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
        case 'triangle':
          shape = new fabric.Triangle({
            width: size,
            height: size,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            angle: Math.random() * 360,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
        case 'rect':
          shape = new fabric.Rect({
            width: size,
            height: size,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            angle: Math.random() * 45,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
      }
      pattern.push(shape);
    }
    return pattern;
  }

  function createGeometricPattern(theme) {
    const pattern = [];
    const shapes = ['rect', 'circle', 'triangle', 'polygon'];
    const size = 20 + Math.random() * 30;
    
    // Create main geometric shapes
    for(let i = 0; i < 12; i++) {
      const shapeType = shapes[Math.floor(Math.random() * shapes.length)];
      const opacity = 0.1 + Math.random() * 0.15;
      
      let shape;
      switch(shapeType) {
        case 'rect':
          shape = new fabric.Rect({
            width: size,
            height: size,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            angle: Math.random() * 45,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
        case 'circle':
          shape = new fabric.Circle({
            radius: size/2,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
        case 'triangle':
          shape = new fabric.Triangle({
            width: size,
            height: size,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            angle: Math.random() * 360,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
        case 'polygon':
          const sides = 3 + Math.floor(Math.random() * 3);
          const points = [];
          for(let j = 0; j < sides; j++) {
            const angle = (j * 2 * Math.PI) / sides;
            points.push({
              x: Math.cos(angle) * size/2,
              y: Math.sin(angle) * size/2
            });
          }
          shape = new fabric.Polygon(points, {
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            angle: Math.random() * 360,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
      }
      pattern.push(shape);
    }

    // Add connecting lines
    for(let i = 0; i < 15; i++) {
      const x1 = Math.random() * canvas.width;
      const y1 = Math.random() * canvas.height;
      const x2 = x1 + (Math.random() * 100 - 50);
      const y2 = y1 + (Math.random() * 100 - 50);
      
      pattern.push(new fabric.Line([x1, y1, x2, y2], {
        stroke: theme.colorScheme.accent,
        strokeWidth: 1 + Math.random(),
        opacity: 0.1 + Math.random() * 0.1
      }));
    }
    return pattern;
  }

  function createCurvedPattern(theme) {
    const pattern = [];
    const curves = 5 + Math.floor(Math.random() * 3);
    
    // Create main curved lines
    for(let i = 0; i < curves; i++) {
      const controlPoints = [];
      const segments = 4 + Math.floor(Math.random() * 3);
      
      for(let j = 0; j < segments; j++) {
        controlPoints.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height
        });
      }
      
      let path = `M ${controlPoints[0].x} ${controlPoints[0].y}`;
      for(let j = 1; j < controlPoints.length; j++) {
        path += ` Q ${controlPoints[j].x} ${controlPoints[j].y},
                  ${controlPoints[j].x} ${controlPoints[j].y}`;
      }
      
      pattern.push(new fabric.Path(path, {
        fill: 'transparent',
        stroke: theme.colorScheme.accent,
        strokeWidth: 2 + Math.random() * 2,
        opacity: 0.15 + Math.random() * 0.1
      }));
    }

    // Add floating dots along the curves
    for(let i = 0; i < 20; i++) {
      pattern.push(new fabric.Circle({
        radius: 2 + Math.random() * 3,
        left: Math.random() * canvas.width,
        top: Math.random() * canvas.height,
        fill: theme.colorScheme.accent,
        opacity: 0.2 + Math.random() * 0.2
      }));
    }
    return pattern;
  }

  function createGridPattern(theme) {
    const pattern = [];
    const spacing = 25 + Math.random() * 15;
    const dotSize = 2 + Math.random() * 2;
    
    // Create grid lines with varying opacities
    for(let x = 0; x < canvas.width; x += spacing) {
      pattern.push(new fabric.Line([x, 0, x, canvas.height], {
        stroke: theme.colorScheme.accent,
        strokeWidth: 0.5 + Math.random(),
        opacity: 0.05 + Math.random() * 0.05
      }));
    }
    for(let y = 0; y < canvas.height; y += spacing) {
      pattern.push(new fabric.Line([0, y, canvas.width, y], {
        stroke: theme.colorScheme.accent,
        strokeWidth: 0.5 + Math.random(),
        opacity: 0.05 + Math.random() * 0.05
      }));
    }
    
    // Add dots at intersections with varying sizes
    for(let x = 0; x < canvas.width; x += spacing) {
      for(let y = 0; y < canvas.height; y += spacing) {
        if(Math.random() > 0.7) {
          pattern.push(new fabric.Circle({
            left: x,
            top: y,
            radius: dotSize + Math.random() * 2,
            fill: theme.colorScheme.accent,
            opacity: 0.2 + Math.random() * 0.2
          }));
        }
      }
    }

    // Add floating elements
    for(let i = 0; i < 10; i++) {
      const size = 5 + Math.random() * 10;
      pattern.push(new fabric.Circle({
        radius: size/2,
        left: Math.random() * canvas.width,
        top: Math.random() * canvas.height,
        fill: theme.colorScheme.accent,
        opacity: 0.1 + Math.random() * 0.1
      }));
    }
    return pattern;
  }

  function createSimplePattern(theme) {
    const pattern = [];
    const elementCount = 15;
    const shapes = ['circle', 'rect', 'triangle', 'polygon'];
    
    // Create main shapes
    for(let i = 0; i < elementCount; i++) {
      const shapeType = shapes[Math.floor(Math.random() * shapes.length)];
      const size = 8 + Math.random() * 20;
      const opacity = 0.1 + Math.random() * 0.15;
      
      let shape;
      switch(shapeType) {
        case 'circle':
          shape = new fabric.Circle({
            radius: size/2,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
        case 'rect':
          shape = new fabric.Rect({
            width: size,
            height: size,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            angle: Math.random() * 45,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
        case 'triangle':
          shape = new fabric.Triangle({
            width: size,
            height: size,
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            angle: Math.random() * 360,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
        case 'polygon':
          const sides = 3 + Math.floor(Math.random() * 3);
          const points = [];
          for(let j = 0; j < sides; j++) {
            const angle = (j * 2 * Math.PI) / sides;
            points.push({
              x: Math.cos(angle) * size/2,
              y: Math.sin(angle) * size/2
            });
          }
          shape = new fabric.Polygon(points, {
            left: Math.random() * canvas.width,
            top: Math.random() * canvas.height,
            angle: Math.random() * 360,
            fill: theme.colorScheme.accent,
            opacity: opacity
          });
          break;
      }
      pattern.push(shape);
    }

    // Add connecting lines
    for(let i = 0; i < 10; i++) {
      const x1 = Math.random() * canvas.width;
      const y1 = Math.random() * canvas.height;
      const x2 = x1 + (Math.random() * 100 - 50);
      const y2 = y1 + (Math.random() * 100 - 50);
      
      pattern.push(new fabric.Line([x1, y1, x2, y2], {
        stroke: theme.colorScheme.accent,
        strokeWidth: 1 + Math.random(),
        opacity: 0.1 + Math.random() * 0.1
      }));
    }
    return pattern;
  }

  // Update AI suggestions display
  function updateAISuggestions(theme) {
    const suggestionsDiv = document.getElementById('aiSuggestions');
    suggestionsDiv.innerHTML = `
      <p><strong>Design Theme:</strong> ${theme.category} style</p>
      <p><strong>Pattern:</strong> ${theme.mainPattern}</p>
      <p><strong>Color Scheme:</strong></p>
      <div class="theme-preview">
        <div class="color-sample" style="background-color: ${theme.colorScheme.primary}"></div>
        <div class="color-sample" style="background-color: ${theme.colorScheme.secondary}"></div>
        <div class="color-sample" style="background-color: ${theme.colorScheme.accent}"></div>
      </div>
    `;
  }

  // Calculate optimal font size based on text length and available space
  function calculateOptimalFontSize(text, maxWidth, maxHeight, minSize = 12, maxSize = 48) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    let fontSize = maxSize;
    
    do {
      ctx.font = `${fontSize}px Arial Black`;
      const metrics = ctx.measureText(text);
      if (metrics.width <= maxWidth && fontSize * 1.2 <= maxHeight) {
        break;
      }
      fontSize -= 2;
    } while (fontSize >= minSize);
    
    return fontSize;
  }

  // Generate random color palette
  function generateColorPalette() {
    const palettes = [
      ['#FF6B6B', '#4ECDC4', '#45B7D1'], // Warm & Cool
      ['#2C3E50', '#3498DB', '#E74C3C'], // Professional
      ['#6C5CE7', '#A8A4FF', '#FFD166'], // Creative
      ['#2D3436', '#00B894', '#FDCB6E'], // Natural
      ['#E84393', '#6C5CE7', '#00CEC9'], // Vibrant
      ['#2D3436', '#636E72', '#B2BEC3']  // Monochrome
    ];
    return palettes[Math.floor(Math.random() * palettes.length)];
  }

  // Generate random pattern type
  function generateRandomPattern() {
    const patterns = ['diagonal', 'geometric', 'curved', 'grid', 'dots', 'waves'];
    return patterns[Math.floor(Math.random() * patterns.length)];
  }

  // Generate modern color palettes based on image colors
  function generateModernPalettes(imageColors) {
    // Ensure imageColors are properly formatted
    const formatColor = (color) => {
      if (!color) return '128,128,128';
      // If color is already in rgb format, extract the values
      if (color.startsWith('rgb')) {
        const matches = color.match(/\d+,\s*\d+,\s*\d+/);
        return matches ? matches[0] : '128,128,128';
      }
      return color;
    };

    const colors = Array.isArray(imageColors) ? 
      imageColors.map(formatColor) : 
      ['128,128,128', '200,200,200', '50,50,50'];

    const palettes = [
      {
        name: 'vibrant',
        colors: [
          `rgba(${colors[0]}, 0.9)`,
          `rgba(${colors[1]}, 0.8)`,
          `rgba(${colors[2]}, 0.7)`
        ],
        accent: '#FFD700'
      },
      {
        name: 'gradient',
        colors: [
          'rgba(255,255,255,0.95)',
          `rgba(${colors[0]}, 0.3)`,
          `rgba(${colors[1]}, 0.5)`
        ],
        accent: `rgba(${colors[2]}, 0.8)`
      },
      {
        name: 'modern',
        colors: [
          'rgba(240,240,240,0.95)',
          `rgba(${colors[0]}, 0.6)`,
          '#2C3E50'
        ],
        accent: '#E74C3C'
      }
    ];
    return palettes[Math.floor(Math.random() * palettes.length)];
  }

  // Generate a short, attractive description without API
  function generateShortDescription(description) {
    // Extract key phrases and create a compelling short description
    const words = description.split(' ');
    if (words.length <= 6) return description;
    
    // Get first 6 words and add ellipsis
    return words.slice(0, 6).join(' ') + '...';
  }

  // Function to generate design using LLM vision model
  async function generateDesignPrompt(productDetails, imageColors) {
    try {
      // Prepare the system prompt for the LLM
      const systemPrompt = {
        role: "system",
        content: `You are an innovative banner designer AI that creates unique, eye-catching designs. For each request, randomly select one of these distinct style approaches:

1. Minimalist & Modern:
   - Clean lines, lots of whitespace
   - Subtle gradients
   - Sans-serif typography
   - Geometric accents

2. Bold & Vibrant:
   - High contrast colors
   - Dynamic diagonal elements
   - Large typography
   - Energetic patterns

3. Luxury & Premium:
   - Dark themes with gold/silver accents
   - Elegant serif fonts
   - Diamond/geometric patterns
   - Sophisticated gradients

4. Tech & Future:
   - Neon accents
   - Grid-based patterns
   - Glowing effects
   - Circuit-like elements

5. Natural & Organic:
   - Earth tones
   - Flowing curves
   - Organic shapes
   - Textured backgrounds

6. Playful & Creative:
   - Bright color combinations
   - Fun patterns (dots, waves, etc.)
   - Playful typography
   - Floating elements

7. Corporate & Professional:
   - Business color schemes
   - Clean layout
   - Traditional typography
   - Subtle patterns

8. Retro & Vintage:
   - Classic color palettes
   - Retro typography
   - Texture overlays
   - Badge-style elements

Generate a banner design specification in the following JSON format that's compatible with Fabric.js. Choose ONE style randomly and adapt it to the product context:

{
  "design": {
    "background": {
      "type": "gradient|pattern|solid",
      "colors": ["color1", "color2"],
      "pattern": {
        "type": "modern|organic|geometric|etc",
        "elements": [
          {
            "type": "circles|lines|dots|waves|etc",
            "count": number,
            "opacity": number,
            "size": { "min": number, "max": number }
          }
        ]
      }
    },
    "image": {
      "frame": {
        "type": "rounded|sharp|circular|floating|etc",
        "style": {
          "shadow": boolean,
          "borderRadius": number,
          "padding": number,
          "border": "string|null"
        }
      },
      "position": {
        "x": number|"percent",
        "y": number|"center",
        "width": "percent",
        "height": "percent"
      }
    },
    "text": {
      "title": {
        "content": "string",
        "font": "string",
        "size": number,
        "color": "string",
        "position": {
          "x": "percent",
          "y": "percent"
        },
        "maxWidth": "percent"
      },
      "description": {
        "content": "string",
        "font": "string",
        "size": number,
        "color": "string",
        "position": {
          "x": "percent",
          "y": "percent"
        },
        "maxWidth": "percent",
        "lineHeight": number
      }
    },
    "cta": {
      "type": "button",
      "text": "string",
      "style": {
        "background": "gradient|solid",
        "colors": ["color1", "color2"],
        "borderRadius": number,
        "shadow": boolean,
        "padding": {
          "x": number,
          "y": number
        }
      },
      "position": {
        "x": "percent",
        "y": "percent",
        "width": number,
        "height": number
      }
    }
  }
}`
      };

      // Prepare the user prompt with product details and image analysis
      const userPrompt = {
        role: "user",
        content: JSON.stringify({
          product: {
            name: productDetails.name,
            description: productDetails.description,
            price: productDetails.price,
            designPreferences: productDetails.designPrompt
          },
          imageAnalysis: {
            dominantColors: imageColors,
            suggestedPalette: generateModernPalettes(imageColors)
          },
          canvasSpecs: {
            width: canvas.width,
            height: canvas.height,
            aspectRatio: canvas.width / canvas.height
          },
          designRequirements: {
            mustInclude: [
              "Product image with appropriate framing",
              "Clear headline with product name",
              "Compelling description or tagline",
              "Strong call-to-action button",
              "Visually appealing background",
              "Professional typography",
              "Balanced layout"
            ]
          }
        })
      };

      // Call the LLM API
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer `
        },
        body: JSON.stringify({
          model: "gpt-4",
          messages: [
            systemPrompt,
            userPrompt
          ],
          max_tokens: 1500,
          temperature: 0.8
        })
      });

      if (!response.ok) {
        throw new Error('Failed to get design from LLM');
      }

      const data = await response.json();
      const designSpec = JSON.parse(data.choices[0].message.content);

      // Validate and process the design specification
      return validateAndProcessDesign(designSpec) || generateFallbackDesign(productDetails, imageColors);
    } catch (error) {
      console.error('Error generating design:', error);
      return generateFallbackDesign(productDetails, imageColors);
    }
  }

  // Function to validate and process the LLM-generated design
  function validateAndProcessDesign(designSpec) {
    try {
      // Check if we have a valid design object
      if (!designSpec || !designSpec.design) {
        console.error('Invalid design specification structure');
        return null;
      }
    // Ensure all required properties exist
      const requiredProperties = [
        'background',
        'image',
        'text',
        'cta'
      ];

      const hasAllProperties = requiredProperties.every(prop => 
        designSpec.design[prop]
      );

      if (!hasAllProperties) {
        console.error('Missing required design properties');
        return null;
      }

      // Process and optimize the design specification
      const processedDesign = {
        design: {
          ...designSpec.design,
          // Ensure text elements don't overlap
          text: processTextLayout(designSpec.design.text),
          // Optimize image placement
          image: processImagePlacement(designSpec.design.image),
          // Add default effects if not present
          effects: {
            shadows: {
              enabled: true,
              maxBlur: 15
            },
            opacity: {
              min: 0.1,
              max: 0.9
            },
            ...designSpec.design.effects
          }
        }
      };

      return processedDesign;
    } catch (error) {
      console.error('Error processing design spec:', error);
      return null;
    }
  }

  // Function to process text layout and prevent overlapping
  function processTextLayout(textSpec) {
    const textElements = Object.entries(textSpec);
    let currentY = canvas.height * 0.2;
    const spacing = canvas.height * 0.05;

    return Object.fromEntries(
      textElements.map(([key, element]) => {
        const processedElement = {
          ...element,
          position: {
            ...element.position,
            y: currentY
          }
        };
        currentY += (element.size || 20) * 1.5 + spacing;
        return [key, processedElement];
      })
    );
  }

  // Function to optimize image placement
  function processImagePlacement(imageSpec) {
    return {
      ...imageSpec,
      position: {
        ...imageSpec.position,
        width: Math.min(imageSpec.position.width || "40%", "50%"),
        height: Math.min(imageSpec.position.height || "80%", "90%")
      },
      frame: {
        ...imageSpec.frame,
        padding: Math.min(imageSpec.frame?.padding || 15, 25)
      }
    };
  }

  // Generate fallback design if LLM fails
  function generateFallbackDesign(productDetails, imageColors) {
    // Format the colors properly
    const formattedColors = imageColors.map(color => {
      if (color.startsWith('rgb')) {
        return color.replace('rgb(', '').replace(')', '');
      }
      return color;
    });

    return {
      design: {
        background: {
          type: "gradient",
          colors: [
            `rgba(${formattedColors[0]},0.98)`,
            `rgba(${formattedColors[1]},0.95)`
          ],
          pattern: {
            type: "modern",
            elements: [
              {
                type: "circles",
                count: 30,
                opacity: 0.1,
                size: { min: 10, max: 40 }
              }
            ]
          }
        },
        image: {
          frame: {
            type: "rounded",
            style: {
              shadow: true,
              borderRadius: 10,
              padding: 15
            }
          },
          position: {
            x: 40,
            y: "center",
            width: "35%",
            height: "80%"
          }
        },
        text: {
          title: {
            content: productDetails.name,
            font: "Arial Black",
            size: 32,
            color: "#2C3E50",
            position: {
              x: "45%",
              y: "20%"
            },
            maxWidth: "50%"
          },
          description: {
            content: productDetails.description,
            font: "Arial",
            size: 18,
            color: "#34495E",
            position: {
              x: "45%",
              y: "45%"
            },
            maxWidth: "50%",
            lineHeight: 1.4
          }
        },
        cta: {
          type: "button",
          text: productDetails.price ? `Buy Now - ${productDetails.price}` : "Shop Now",
          style: {
            background: "gradient",
            colors: ["#3498DB", "#2980B9"],
            borderRadius: 25,
            shadow: true,
            padding: {
              x: 30,
              y: 12
            }
          },
          position: {
            x: "45%",
            y: "70%",
            width: 160,
            height: 45
          }
        },
        layout: {
          type: "standard",
          spacing: 20
        },
        typography: {
          titleFont: "Arial Black",
          bodyFont: "Arial"
        },
        effects: {
          shadows: {
            enabled: true,
            maxBlur: 15
          },
          opacity: {
            min: 0.1,
            max: 0.9
          }
        }
      }
    };
  }

  // Function to generate AI response
  async function generateAIResponse(prompt) {
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
        },
        body: JSON.stringify({
          model: "gpt-4",
          messages: [
            {
              role: "system",
              content: "You are a creative banner designer AI that generates engaging content and design specifications."
            },
            {
              role: "user",
              content: prompt
            }
          ],
          max_tokens: 500,
          temperature: 0.7
        })
      });

      if (!response.ok) {
        throw new Error('Failed to get AI response');
      }

      const data = await response.json();
      return data.choices[0].message.content;
    } catch (error) {
      console.error('Error generating AI response:', error);
      // Return a fallback response if API call fails
      return JSON.stringify({
        title: "Premium Product",
        slogan: "Experience Excellence",
        offerText: "Limited Time Offer",
        style: {
          theme: "modern",
          colors: {
            primary: "#2C3E50",
            secondary: "#3498DB",
            text: "#FFFFFF"
          },
          background: {
            type: "gradient",
            texture: "subtle",
            mood: "professional"
          }
        }
      });
    }
  }

  // Modified generateBanner function to handle ChatGPT-generated design specs
  async function generateBanner(description) {
    try {
      canvas.clear();

      // Process description to generate banner content
      const processDescription = async (desc) => {
        try {
          const prompt = `Create a banner design for the following description: "${desc}"
          Return only valid JSON with no additional text.`;
          const response = await generateAIResponse(prompt);
          
          // Default design structure that will always be valid
          const defaultDesign = {
            design: {
              layout: "diagonal_split",
              style: {
                colors: {
                  primary: "#F8F9FA",
                  secondary: "#E9ECEF",
                  accent: "#0066CC",
                  text: "#212529"
                },
                background: {
                  texture: "subtle",
                  mood: "professional"
                }
              },
              text: {
                special_offer: {
                  content: "SPECIAL OFFER",
                  font: "Arial Black",
                  size: 24,
                  color: "#212529",
                  position: { x: 60, y: 10 }
                },
                main_heading: {
                  content: desc.split(' ').slice(0, 3).join(' ').toUpperCase(),
                  font: "Arial Black",
                  size: 64,
                  color: "#212529",
                  stroke: { color: "#212529", width: 2 },
                  position: { x: 60, y: 30 }
                },
                subtitle: {
                  content: "LIMITED TIME ONLY",
                  font: "Arial",
                  size: 28,
                  color: "#212529",
                  position: { x: 60, y: 50 }
                }
              },
              elements: {
                discount_circle: {
                  type: "circle",
                  content: "20% OFF",
                  position: { x: 45, y: 20 },
                  size: 120,
                  colors: { background: "#0066CC", text: "#FFFFFF" }
                },
                cta_button: {
                  content: "SHOP NOW",
                  style: {
                    background: "#0066CC",
                    color: "#FFFFFF",
                    padding: { x: 30, y: 15 },
                    border_radius: 25
                  },
                  position: { x: 60, y: 70 }
                }
              }
            }
          };

          try {
            // Try to parse the AI response
            const parsedResponse = JSON.parse(response);
            
            // Merge the parsed response with default design, ensuring required properties exist
            return {
              design: {
                ...defaultDesign.design,
                ...parsedResponse.design,
                // Ensure text elements exist
                text: {
                  ...defaultDesign.design.text,
                  ...(parsedResponse.design?.text || {})
                },
                // Ensure elements exist
                elements: {
                  ...defaultDesign.design.elements,
                  ...(parsedResponse.design?.elements || {})
                },
                // Ensure style exists
                style: {
                  ...defaultDesign.design.style,
                  ...(parsedResponse.design?.style || {})
                }
              }
            };
          } catch (parseError) {
            console.error('Error parsing JSON response:', parseError);
            return defaultDesign;
          }
        } catch (error) {
          console.error('Error in processDescription:', error);
          return defaultDesign;
        }
      };

      // Generate banner content from description
      const content = await processDescription(description);
      
      // Create themed background
      const createThemedBackground = () => {
        // Generate random background colors
        const generateBackgroundColors = () => {
          const schemes = [
            { primary: '#F8F9FA', secondary: '#E9ECEF' }, // Light
            { primary: '#ECE9E6', secondary: '#FFFFFF' }, // Clean
            { primary: '#2980B9', secondary: '#6DD5FA' }, // Blue
            { primary: '#11998E', secondary: '#38EF7D' }, // Green
            { primary: '#FC466B', secondary: '#3F5EFB' }, // Pink
            { primary: '#8E2DE2', secondary: '#4A00E0' }, // Purple
            { primary: '#373B44', secondary: '#4286F4' }, // Dark
            { primary: '#FF8008', secondary: '#FFC837' }  // Orange
          ];
          return schemes[Math.floor(Math.random() * schemes.length)];
        };

        const bgColors = generateBackgroundColors();

        // Create gradient background
        const gradient = new fabric.Gradient({
          type: 'linear',
          coords: {
            x1: 0,
            y1: 0,
            x2: canvas.width,
            y2: canvas.height
          },
          colorStops: [
            { offset: 0, color: bgColors.primary },
            { offset: 1, color: bgColors.secondary }
          ]
        });

        const background = new fabric.Rect({
          left: 0,
          top: 0,
          width: canvas.width,
          height: canvas.height,
          fill: gradient
        });

        canvas.add(background);
        background.sendToBack();

        // Add subtle texture
        for (let i = 0; i < 30; i++) {
          const shapeType = Math.random();
          const size = 5 + Math.random() * 15;
          const opacity = 0.05 + Math.random() * 0.1;
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          
          let shape;
          if (shapeType < 0.33) {
            shape = new fabric.Circle({
              radius: size / 2,
              left: x,
              top: y,
              fill: '#000000',
              opacity: opacity
            });
          } else if (shapeType < 0.66) {
            const angle = Math.random() * Math.PI * 2;
            const length = 20 + Math.random() * 40;
            shape = new fabric.Line([
              x,
              y,
              x + Math.cos(angle) * length,
              y + Math.sin(angle) * length
            ], {
              stroke: '#000000',
              strokeWidth: 1,
              opacity: opacity
            });
          } else {
            shape = new fabric.Rect({
              width: size,
              height: size,
              left: x,
              top: y,
              angle: Math.random() * 45,
              fill: '#000000',
              opacity: opacity
            });
          }
          canvas.add(shape);
          shape.sendToBack();
        }
      };

      // Add product image with proper scaling and positioning
      if (currentImage) {
        const maxWidth = canvas.width * 0.5;
        const maxHeight = canvas.height * 0.95;
        
        // Calculate scale while maintaining aspect ratio
        const scaleX = maxWidth / currentImage.width;
        const scaleY = maxHeight / currentImage.height;
        const scale = Math.min(scaleX, scaleY);
        
        // Calculate centered position
        const scaledWidth = currentImage.width * scale;
        const scaledHeight = currentImage.height * scale;
        const left = (maxWidth - scaledWidth) / 2;
        const top = (canvas.height - scaledHeight) / 2;

        const productImg = new fabric.Image(currentImage, {
          left: left,
          top: top,
          scaleX: scale,
          scaleY: scale,
          selectable: false
        });

        canvas.add(productImg);
        productImg.sendToBack();
      }

      // Create background
      createThemedBackground();

      // Add text elements with theme-appropriate styling
      const addTextElements = () => {
        const textAreaWidth = canvas.width * 0.45;
        const textStartX = canvas.width * 0.55;
        
        // Special offer text
        const specialOffer = new fabric.Textbox("SPECIAL OFFER", {
          left: textStartX,
          top: canvas.height * 0.1,
          width: textAreaWidth,
          fontSize: 36,
          fontFamily: 'Arial',
          fill: '#FF4444',
          fontWeight: 'bold',
          textAlign: 'left'
        });

        // Main heading - reduced font size and adjusted position
        const mainHeading = new fabric.Textbox(description.split(' ').slice(0, 4).join(' '), {
          left: textStartX,
          top: canvas.height * 0.25,
          width: textAreaWidth,
          fontSize: 32,
          fontFamily: 'Arial',
          fill: '#333333',
          fontWeight: 'bold',
          textAlign: 'left'
        });

        // Subtitle - adjusted position
        const subtitle = new fabric.Textbox("LIMITED TIME ONLY", {
          left: textStartX,
          top: canvas.height * 0.45,
          width: textAreaWidth,
          fontSize: 24,
          fontFamily: 'Arial',
          fill: '#666666',
          textAlign: 'left'
        });

        // Discount circle - moved to right side
        const circleRadius = 50;
        const circle = new fabric.Circle({
          radius: circleRadius,
          fill: '#FF4444',
          left: canvas.width * 0.85,
          top: canvas.height * 0.15,
          opacity: 0.9
        });

        // Discount text - adjusted to match circle position
        const discountText = new fabric.Text("30%\nOFF", {
          left: circle.left + circleRadius,
          top: circle.top + circleRadius,
          fontSize: 24,
          fontFamily: 'Arial',
          fill: '#FFFFFF',
          fontWeight: 'bold',
          textAlign: 'center',
          originX: 'center',
          originY: 'center'
        });

        // CTA button - adjusted position and size
        const buttonWidth = 160;
        const buttonHeight = 45;
        const button = new fabric.Rect({
          left: textStartX,
          top: canvas.height * 0.65,
          width: buttonWidth,
          height: buttonHeight,
          fill: '#4CAF50',
          rx: 8,
          ry: 8
        });

        // Button text - adjusted to match button position
        const buttonText = new fabric.Text("SHOP NOW", {
          left: button.left + buttonWidth / 2,
          top: button.top + buttonHeight / 2,
          fontSize: 20,
          fontFamily: 'Arial',
          fill: '#FFFFFF',
          fontWeight: 'bold',
          textAlign: 'center',
          originX: 'center',
          originY: 'center'
        });

        // Add all elements to canvas
        canvas.add(specialOffer);
        canvas.add(mainHeading);
        canvas.add(subtitle);
        canvas.add(circle);
        canvas.add(discountText);
        canvas.add(button);
        canvas.add(buttonText);
      };

      // Add text elements
      addTextElements();

      canvas.renderAll();

    } catch (error) {
      console.error('Error generating banner:', error);
      // Create a basic fallback banner
      createFallbackBanner(description);
    }
  }

  // Add a fallback banner creation function
  function createFallbackBanner(description) {
    try {
      canvas.clear();

      // Create simple gradient background
      const background = new fabric.Rect({
        left: 0,
        top: 0,
        width: canvas.width,
        height: canvas.height,
        fill: new fabric.Gradient({
          type: 'linear',
          coords: {
            x1: 0,
            y1: 0,
            x2: canvas.width,
            y2: canvas.height
          },
          colorStops: [
            { offset: 0, color: '#F8F9FA' },
            { offset: 1, color: '#E9ECEF' }
          ]
        })
      });

      // Add product image if available
      if (currentImage) {
        const maxHeight = canvas.height * 0.8;
        const maxWidth = canvas.width * 0.4;
        const scale = Math.min(maxHeight / currentImage.height, maxWidth / currentImage.width);

        const productImg = new fabric.Image(currentImage, {
          left: canvas.width * 0.05,
          top: canvas.height * 0.1,
          scaleX: scale,
          scaleY: scale
        });

        canvas.add(productImg);
      }

      // Add basic text elements
      const title = new fabric.Text(description.split(' ').slice(0, 3).join(' ').toUpperCase(), {
        left: canvas.width * 0.5,
        top: canvas.height * 0.2,
        fontSize: 36,
        fontFamily: 'Arial Black',
        fill: '#212529'
      });

      const subtitle = new fabric.Text('Limited Time Offer', {
        left: canvas.width * 0.5,
        top: canvas.height * 0.4,
        fontSize: 24,
        fontFamily: 'Arial',
        fill: '#666666'
      });

      const button = new fabric.Rect({
        left: canvas.width * 0.5,
        top: canvas.height * 0.6,
        width: 160,
        height: 45,
        fill: '#0066CC',
        rx: 22.5,
        ry: 22.5
      });

      const buttonText = new fabric.Text('Shop Now', {
        left: canvas.width * 0.5 + 80,
        top: canvas.height * 0.6 + 22.5,
        fontSize: 20,
        fontFamily: 'Arial Black',
        fill: '#FFFFFF',
        originX: 'center',
        originY: 'center'
      });

      canvas.add(background);
      canvas.add(title);
      canvas.add(subtitle);
      canvas.add(button);
      canvas.add(buttonText);

      canvas.renderAll();
    } catch (fallbackError) {
      console.error('Error creating fallback banner:', fallbackError);
      showError('Failed to generate banner. Please try again.');
    }
  }

  // Helper function to generate smooth curves
  const generateSmoothCurvePath = (points) => {
    if (points.length < 2) return '';
    
    let path = `M ${points[0].x} ${points[0].y}`;
    
    for (let i = 1; i < points.length - 2; i++) {
      const xc = (points[i].x + points[i + 1].x) / 2;
      const yc = (points[i].y + points[i + 1].y) / 2;
      path += ` Q ${points[i].x} ${points[i].y}, ${xc} ${yc}`;
    }
    
    path += ` Q ${points[points.length - 2].x} ${points[points.length - 2].y}, 
              ${points[points.length - 1].x} ${points[points.length - 1].y}`;
    
    return path;
  };

  // Initialize MobileNet model
  async function initModel() {
    try {
      model = await mobilenet.load();
      console.log('MobileNet model loaded');
    } catch (error) {
      console.error('Error loading model:', error);
      showError('Failed to load AI model. Please try again later.');
    }
  }

  // Initialize canvas
  function initCanvas() {
    canvas = new fabric.Canvas('adCanvas');
    canvas.setWidth(800);
    canvas.setHeight(200);
  }

  // Show error message on canvas
  function showError(message) {
    if (canvas) {
      canvas.clear();
      const errorText = new fabric.Text(message, {
        left: canvas.width / 2,
        top: canvas.height / 2,
        fontSize: 20,
    fontFamily: 'Arial',
        fill: '#ff0000',
        originX: 'center',
        originY: 'center'
      });
      canvas.add(errorText);
      canvas.renderAll();
    }
  }

  // Wait for image to load
  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = src;
    });
  }

  // Analyze image using MobileNet
  async function analyzeImage(imageElement) {
    try {
      // Wait for the image to be fully loaded
      await new Promise(resolve => {
        if (imageElement.complete) {
          resolve();
        } else {
          imageElement.onload = resolve;
        }
      });

      // Check if image has valid dimensions
      if (imageElement.width === 0 || imageElement.height === 0) {
        throw new Error('Invalid image dimensions');
      }

      // Create a temporary canvas with the image
      const tempCanvas = document.createElement('canvas');
      const ctx = tempCanvas.getContext('2d');
      tempCanvas.width = imageElement.width;
      tempCanvas.height = imageElement.height;
      ctx.drawImage(imageElement, 0, 0);

      // Perform classification
      const predictions = await model.classify(imageElement);
      
      imageFeatures = {
        predictions,
        dominantColors: await extractDominantColors(imageElement),
        dimensions: {
          width: imageElement.width,
          height: imageElement.height,
          aspectRatio: imageElement.width / imageElement.height
        }
      };
      
      displayFeatures(imageFeatures);
      return imageFeatures;
    } catch (error) {
      console.error('Error analyzing image:', error);
      showError('Failed to analyze image. Please try a different image.');
      imageFeatures = {
        predictions: [{ className: 'Product', probability: 1 }],
        dominantColors: ['#333333', '#666666', '#999999'],
        dimensions: { width: 0, height: 0, aspectRatio: 1 }
      };
    }
  }

  // Extract dominant colors from image
  async function extractDominantColors(imageElement) {
    try {
      const tempCanvas = document.createElement('canvas');
      const ctx = tempCanvas.getContext('2d');
      tempCanvas.width = 50;  // Reduce size for performance
      tempCanvas.height = 50;
      ctx.drawImage(imageElement, 0, 0);
      const imageData = ctx.getImageData(0, 0, 50, 50).data;
      
      const colorCounts = {};
      for (let i = 0; i < imageData.length; i += 4) {
        // Skip transparent pixels
        if (imageData[i + 3] < 128) continue;
        
        const color = `${imageData[i]},${imageData[i+1]},${imageData[i+2]}`;
        colorCounts[color] = (colorCounts[color] || 0) + 1;
      }
      
      // Default colors if none are found
      const defaultColors = ['#333333', '#666666', '#999999'];
      
      const extractedColors = Object.entries(colorCounts)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3)
        .map(([color]) => `rgb(${color})`);

      // Return extracted colors or fall back to defaults
      return extractedColors.length > 0 ? extractedColors : defaultColors;
    } catch (error) {
      console.error('Error extracting colors:', error);
      return ['#333333', '#666666', '#999999']; // Default colors on error
    }
  }

  // Display detected features
  function displayFeatures(features) {
    const featuresDiv = document.getElementById('imageFeatures');
    featuresDiv.innerHTML = `
      <p><strong>Detected:</strong> ${features.predictions[0].className}</p>
      <p><strong>Confidence:</strong> ${Math.round(features.predictions[0].probability * 100)}%</p>
      <div style="display: flex; gap: 10px;">
        <strong>Colors:</strong>
        ${features.dominantColors.map(color => 
          `<div style="width: 20px; height: 20px; background: ${color}; border: 1px solid #000;"></div>`
        ).join('')}
      </div>
    `;
  }

  // Helper function to shade colors
  function shadeColor(color, percent) {
    let R = parseInt(color.substring(1,3),16);
    let G = parseInt(color.substring(3,5),16);
    let B = parseInt(color.substring(5,7),16);

    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);

    R = (R<255)?R:255;  
    G = (G<255)?G:255;  
    B = (B<255)?B:255;  

    const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
    const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
    const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

    return "#"+RR+GG+BB;
  }

  // Event Listeners
  document.addEventListener('DOMContentLoaded', async () => {
    await initModel();
    initCanvas();

    const imageUpload = document.getElementById('productImage');
    const imagePreview = document.getElementById('imagePreview');
    const generateButton = document.getElementById('generateBanner');
    const downloadButton = document.getElementById('downloadBanner');
    const loadingIndicator = document.getElementById('loadingIndicator');

    imageUpload.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        try {
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const img = await loadImage(e.target.result);
              imagePreview.src = img.src;
              imagePreview.style.display = 'block';
              currentImage = img;
              
              // Extract colors from image
              const imageColors = await extractDominantColors(img);
              console.log('Extracted colors:', imageColors);
            } catch (error) {
              console.error('Error loading preview image:', error);
              showError('Failed to load image. Please try a different image.');
            }
          };
          reader.onerror = () => {
            showError('Failed to read image file. Please try again.');
          };
          reader.readAsDataURL(file);
        } catch (error) {
          console.error('Error handling file upload:', error);
          showError('Failed to process image. Please try again.');
        }
      }
    });

    generateButton.addEventListener('click', async () => {
      const productDescription = document.getElementById('productDescription').value;
      const designPrompt = document.getElementById('designPrompt').value;

      if (!productDescription) {
        showError('Please provide a description');
        return;
      }

      loadingIndicator.style.display = 'block';

      try {
        // Extract colors from current image
        const imageColors = currentImage ? await extractDominantColors(currentImage) : null;

        const productDetails = {
          description: productDescription,
          designPrompt: designPrompt
        };

        const designSpecs = await generateDesignPrompt(productDetails, imageColors);
        await generateBanner(productDetails.description);
      } catch (error) {
        console.error('Error:', error);
        showError('Failed to generate banner. Please try again.');
      } finally {
        loadingIndicator.style.display = 'none';
      }
    });

    downloadButton.addEventListener('click', () => {
      if (canvas) {
        const link = document.createElement('a');
        link.download = 'product-banner.png';
        link.href = canvas.toDataURL();
        link.click();
      }
    });
  });
</script>

</body>
</html>
